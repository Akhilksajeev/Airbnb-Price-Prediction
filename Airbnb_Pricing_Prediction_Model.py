# -*- coding: utf-8 -*-
"""Airbnb_Pricing_Prediction_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K0K1N4MR9lWqKy4RhITQrUmUqFAA_yUO
"""

# Import necessary libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.preprocessing import StandardScaler

# Load the dataset
df = pd.read_csv('Airbnb_data.csv')
df.shape

# Display the first few rows of the dataset
df.head()

features = [
    'accommodates', 'bathrooms', 'bedrooms','beds', 'cleaning_fee',
    'host_response_rate', 'instant_bookable', 'review_scores_rating',
    'latitude', 'longitude','cancellation_policy', 'log_price'
]

# Filter the dataset to include only the important features
df = df[features]

# Display the filtered data to check
df.head()

# Check for missing values
missing_data = df.isnull().sum()
print(f"\nMissing Values:\n{missing_data[missing_data > 0]}")

# Create a box plot to visualize outliers
plt.figure(figsize=(12, 6))
sns.boxplot(data=df)

# Add title and format x-axis labels
plt.title("Box Plot of Numerical Features (Outlier Detection)")
plt.xticks(rotation=45)
plt.show()

# Convert 'host_response_rate' to numeric by removing '%' and then converting to float
df['host_response_rate'] = df['host_response_rate'].str.replace('%', '').astype(float)

# Handle missing values in numerical columns with median
df['bathrooms'].fillna(df['bathrooms'].median(), inplace=True)
df['bedrooms'].fillna(df['bedrooms'].median(), inplace=True)
df['beds'].fillna(df['beds'].median(), inplace=True)
df['host_response_rate'].fillna(df['host_response_rate'].median(), inplace=True)
df['review_scores_rating'].fillna(df['review_scores_rating'].median(), inplace=True)

missing_data = df.isnull().sum()
print(f"\nMissing Values:\n{missing_data[missing_data > 0]}")

# Initialize LabelEncoder for cleaning_fee and instant_bookable columns
label_encoder = LabelEncoder()
# Label encoding for cleaning_fee (TRUE/FALSE) and instant_bookable (t/f)
df['cleaning_fee'] = label_encoder.fit_transform(df['cleaning_fee'])
df['instant_bookable'] = label_encoder.fit_transform(df['instant_bookable'])
df['cancellation_policy'] = label_encoder.fit_transform(df['cancellation_policy'])

sns.pairplot(df)

# Show the plot
plt.show()

#Compute the correlation matrix
correlation_matrix = df.corr()

plt.figure(figsize=(10, 6))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Correlation Heatmap of Airbnb Dataset")
plt.show()

df.tail()

# Split data into features (X) and target (y)
X = df.drop(columns=['log_price'])
y = df['log_price']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize StandardScaler
scaler = StandardScaler()

# Fit on the training data and transform both train and test sets
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# 1. Linear Regression Model
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)
lr_pred = lr_model.predict(X_test)

# 2. Random Forest Regressor Model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)
rf_pred = rf_model.predict(X_test)

# 3. XGBoost Regressor Model
xgb_model = XGBRegressor(n_estimators=100, random_state=42)
xgb_model.fit(X_train, y_train)
xgb_pred = xgb_model.predict(X_test)

# Model Evaluation - RMSE, MAE, and R²
def evaluate_model(model_name, y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))  # RMSE
    mae = mean_absolute_error(y_true, y_pred)  # MAE
    r2 = r2_score(y_true, y_pred)  # R²

    print(f'{model_name} - RMSE: {rmse:.4f}, MAE: {mae:.4f}, R²: {r2:.4f}')

# Evaluate models
evaluate_model('Linear Regression', y_test, lr_pred)
evaluate_model('Random Forest Regressor', y_test, rf_pred)
evaluate_model('XGBoost Regressor', y_test, xgb_pred)

# Mapping for cancellation policies
cancellation_mapping = {'strict': 3, 'moderate': 2, 'flexible': 1}

# Function for user input and prediction
def predict_listing_price(model):
    # Ask for user input
    accommodates = int(input("Enter the number of guests the property can accommodate: "))
    bathrooms = float(input("Enter the number of bathrooms: "))
    bedrooms = int(input("Enter the number of bedrooms: "))
    beds = int(input("Enter the number of beds: "))
    cleaning_fee = input("Is there a cleaning fee (TRUE/FALSE)? ").strip().upper() == "TRUE"  # Convert to boolean
    host_response_rate = float(input("Enter host response rate (e.g., 95.0 for 95%): ")) / 100
    instant_bookable = input("Is the listing instantly bookable (t/f)? ").strip().lower() == "t"
    review_scores_rating = float(input("Enter the average review score: "))
    latitude = float(input("Enter the latitude coordinate: "))
    longitude = float(input("Enter the longitude coordinate: "))
    cancellation_policy = input("Enter the cancellation policy (strict, moderate, flexible): ").strip().lower()

    # Prepare the input as a list or array
    input_data = [
        accommodates, bathrooms, bedrooms, beds,
        int(cleaning_fee), host_response_rate, int(instant_bookable),
        review_scores_rating, latitude, longitude,
        cancellation_mapping.get(cancellation_policy, 0)  # Default to 0 if invalid
    ]

    # Convert input data into the right shape (1 row, 11 features)
    input_data = np.array(input_data).reshape(1, -1)

    # Make prediction using the model (log_price prediction)
    log_price_pred = model.predict(input_data)

    # Convert log_price to actual price using exponential function
    actual_price_pred = np.exp(log_price_pred[0])  # Reverse the log transformation

    # Print the result
    print(f"\n\t\tPredicted log_price: {log_price_pred[0]:.4f}")
    print(f"\t\tPredicted actual price: ${actual_price_pred:.2f}")

# Ask user which model to use
model_choice = input("Choose a model for prediction (1.Linear Regression / 2.Random Forest / 3.XGBoost): ").strip().lower()

if model_choice == 'linear regression':
    predict_listing_price(lr_model)
elif model_choice == 'random forest':
    predict_listing_price(rf_model)
elif model_choice == 'xgboost':
    predict_listing_price(xgb_model)
else:
    print("Invalid choice. Please choose one of the available models.")

